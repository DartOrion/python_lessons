# *** Коллекции (контейнеры, структыры данных) ***

# ** Список (list) **

# Создание пустого списка 
my_list = []
my_list = list() # второй мариант

# документ рекомендательного характера (PEP8) стилистка когда.

# # Добавление объекта (элемента) в список 
# my_list.append(100)                        # первый элемент / счёт начинаеться с нуля(0)
# my_list.append(3.14) # вешественое число. Число с палавюшей точкой
# my_list.append("Hello") # строка.
# my_list.append([10,20,30])                 # 4й элемент

# print(my_list)

# Чтоение значений элемента 
# прямая индексация 
# в квадратую скобку указываем инжекс необходимого элемента
# el = my_list[2]
# el = my_list[3][1]  # вызов скисков псоледовательно 

# # обратная индексация
# el = my_list[-1] # последний элемент . наичаеться не с нуля (0)

# # замена значения элемента
# my_list[0] = 2000

#  удаление элемента по значению
# my_list.remove(3.14)

# Удаление элемента по индексу 
# del my_list[-1]

# # Срез списка
# s = "Hello, world!"
# my_list = list(s)

# #синтаксис среза
# my_slice = my_list[2:] # срез со 2го до конца исходного списка
# my_slice = my_list[2:5] # со второго индекса до пятого списка не включительно
# my_slice = my_list[:5]  #  Срез с начала до 5го индекса не включительно

# my_slice = my_list[2:12:2] # срез со 2го индекса до 12го не включительно с шагом 2

# my_slice = my_list[-2:-5:-1] # срез с применением обратной индексацией 

# my_slice = my_list[::-1] # переворот списка (Revers) Зеракальный.

# len() возвращает длину (количество элементов) коллекции
# print(len(my_list))
# print(my_list)
# print(my_slice)

#  *** Кортеж (tuple) ***

#  не изменяемая коллекция (immutable)
# легковеснее, чем список. Работает только чтение и срез, добавлять, менять или удалять нельзя

# #  создание кортежа
# my_tuple = (10, 20, 30, 40, 50)

# my_tuple[0] = 100   ошибочный пример

# print(my_tuple)

# # чтение значения элементов кортежей
# print(my_tuple[0])

# # срезp
# print(my_tuple[2:])


# *** Словарь (dict) ***

#  Изменяемый, упорядоченный тип коллекции

#       пара "ключь-значение"     
# {ключь_1:значение_1, ключь_2:значение_2}

# # создание словоря 
# my_dict = {10:3.14, "abc":[1,2,3]}

# print(my_dict)

# чтоение значений
# print(my_dict["abc"])
# print(my_dict[10])

# data0 = {"name":"Alucard", "age":34, "id":223.5}
# data1 = {"name":"Ben", "age":29, "id":200.9}
# data2 = {"name":"Ayal", "age":39, "id":999.9}

# total_data = {"p0":data0, "p1":data1, "p2":data2}

# # print(total_data["p2"]["id"])

# #  изменене значений
# my_dict["abc"] = "Hello!"

# # добавление новой пары
# # при присвоении нового значения по несуществующему ключу создаеться новая пара с таким же ключём.
# my_dict['A'] = 123 

# # удаление елемента (пары)
# del my_dict['A']

# обновление данных 
# data0 = {"name":"Alucard", "age":34, "id":223.5}

# data0.update({"age":35, "id":400, "W":55.8})   # пример обнволения

# print(data0)

# *** Множество (set) ***

# изменяемый тип коллекций

# Особенности:
# - не упорядоченный тип коллекций (объекты не индексируються)
# - автоматом удаляет дублирующие объекты 

# Создание пустого множества 
my_set = set()

# Cоздание наполненого множесва
my_set = {10, 20, 30}

# добавление элемента
my_set.add(123)

# когда добавляеться значение, которое уже естьво множестве, то оно удаляеться (не добавляется)
my_set.add(30)

# удаление элеменета
my_set.remove(20)
# my_set.remove(40)

# метод удаления без ошибок
my_set.discard(123)

# дано два множества 
w = {"a", "b", "c", "d"}
z = {'b', 'c', 'q'}

# обьединение множеств 
f = w.union(z)
f = w | z    # вариативность обьединения 

# пересечение
f = w.intersection(z)  # показывает (выводит) одинаковые эелементы 
f = w & z              # второй вариант 

# разность
f = w.difference(z)

print(f)

